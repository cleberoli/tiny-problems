<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>tinypy.geometry.intersections API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tinypy.geometry.intersections</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from ast import literal_eval as make_tuple
from datetime import datetime
from typing import Dict, List

from tinypy.geometry.bisection import Bisection
from tinypy.geometry.cone import Cone
from tinypy.geometry.hyperplane import Hyperplane
from tinypy.geometry.region import Region
from tinypy.lp.intersection import IntersectionProblem
from tinypy.polytopes.base_polytope import Polytope
from tinypy.utils.file import create_directory, delete_directory, file_exists, get_full_path


class Intersections:
    &#34;&#34;&#34;Computes the intersections of hyperplanes and solution cones.

    The files are stored in order to speed up the process in case of any kind
    of interruptions.


    Attributes:
        type: The instance type.
        name: The instance name.
        intersection_file: The path where the intersections should be stored.
        polytope: The polytope.
        hyperplanes: The polytope&#39;s set of hyperplanes.
        cones: The polytope&#39;s solution cones.
        intersection_lp: Instance of the intersection linear program model.
    &#34;&#34;&#34;

    type: str
    name: str
    intersection_file: str

    polytope: Polytope
    hyperplanes: Dict[int, &#39;Hyperplane&#39;]
    cones: Dict[int, &#39;Cone&#39;]
    intersection_lp: IntersectionProblem

    def __init__(self, polytope: Polytope):
        &#34;&#34;&#34;Initializes the intersections.

        Args:
            polytope: The polytope.
        &#34;&#34;&#34;
        self.type = polytope.instance.type
        self.name = polytope.instance.name

        self.polytope = polytope
        self.hyperplanes = polytope.H
        self.hyperplanes.update(polytope.extended_H)
        self.cones = polytope.voronoi.cones
        self.intersection_lp = IntersectionProblem(polytope.dimension, polytope.instance.name, polytope.voronoi.cones, polytope.H, True)

    def clear_files(self):
        &#34;&#34;&#34;Deletes the files used to stored previous results.
        &#34;&#34;&#34;
        delete_directory(get_full_path(&#39;files&#39;, &#39;intersections&#39;, self.type))

    def clear_lp_files(self):
        &#34;&#34;&#34;Deletes the files used by the linear program.
        &#34;&#34;&#34;
        self.intersection_lp.clear_files()

    def get_positions(self, region: &#39;Region&#39;, cones: List[int], hyperplanes: List[int]) -&gt; Dict[int, &#39;Bisection&#39;]:
        &#34;&#34;&#34;Returns the the positions of cones with respect to hyperplanes.

        Args:
            region: The region to be considered.
            cones: The cones to be considered.
            hyperplanes: The hyperplanes whose bisections we want.

        Returns:
            The bisections of the given cones for each hyperplane.
        &#34;&#34;&#34;
        self.intersection_file = get_full_path(&#39;files&#39;, &#39;intersections&#39;, self.type, self.name, f&#39;{repr(region)}.tptf&#39;)
        create_directory(get_full_path(&#39;files&#39;, &#39;intersections&#39;, self.type, self.name))

        if file_exists(self.intersection_file):
            positions = self.__read_intersection_file(len(hyperplanes))
        else:
            positions = self.__compute_positions(region, cones, hyperplanes)
            self.__write_intersection_file(region, cones, hyperplanes, positions)

        return positions

    def __compute_positions(self, region: &#39;Region&#39;, reference_cones: List[int], reference_hyperplanes: List[int]) -&gt; Dict[int, &#39;Bisection&#39;]:
        &#34;&#34;&#34;Returns the the positions of cones with respect to hyperplanes.

        Args:
            region: The region to be considered.
            reference_cones: The cones to be considered.
            reference_hyperplanes: The hyperplanes whose bisections we want.

        Returns:
            The bisections of the given cones for each hyperplane.
        &#34;&#34;&#34;
        intersections = self.__compute_intersections(region, reference_cones, reference_hyperplanes)
        positions = dict()

        for h in reference_hyperplanes:
            positions[h] = Bisection()
            cones = [c for (c, value) in intersections[h].items() if value is False]

            for c in cones:
                if self.hyperplanes[h].in_halfspace(self.cones[c].solution):
                    positions[h].add_right(c)
                else:
                    positions[h].add_left(c)

        return positions

    def __compute_intersections(self, region: &#39;Region&#39;, reference_cones: List[int], reference_hyperplanes: List[int]) -&gt; Dict[int, Dict[int, bool]]:
        &#34;&#34;&#34;Computes the intersections of each hyperplane with each cone.

        Args:
            region: The region to be considered.
            reference_cones: The cones to be considered.
            reference_hyperplanes: The hyperplanes whose bisections we want.

        Returns:
            The intersections of the hyperplanes with cones.
        &#34;&#34;&#34;
        intersections = dict()

        for h in reference_hyperplanes:
            intersections[h] = dict()

            for c in reference_cones:
                intersections[h][c] = self.intersection_lp.test_intersection(region, c, h)

        return intersections

    def __read_intersection_file(self, p_size: int) -&gt; Dict[int, &#39;Bisection&#39;]:
        &#34;&#34;&#34;Reads the intersection file.

        Args:
            p_size: The number of hyperplanes.

        Returns:
            The bisections of the given cones for each hyperplane.
        &#34;&#34;&#34;
        positions = dict()

        with open(self.intersection_file, &#39;r&#39;) as file:
            file.readline()     # name
            file.readline()     # type
            file.readline()     # generated
            file.readline()     # region
            file.readline()     # hash
            file.readline()     # hyperplanes
            file.readline()     # solutions
            file.readline()

            file.readline()     # POSITION SECTION
            for _ in range(p_size):
                line = file.readline().split(&#39;:&#39;)
                key = int(line[0].strip())
                bisection_tuple = make_tuple(line[1].strip())
                bisection = Bisection(bisection_tuple[0], bisection_tuple[1])
                positions[key] = bisection

        return positions

    def __write_intersection_file(self, region: &#39;Region&#39;, reference_cones: List[int],
                                  reference_hyperplanes: List[int], positions: Dict[int, &#39;Bisection&#39;]):
        &#34;&#34;&#34;Writes the intersection file.

        Args:
            region: The region to be considered.
            reference_cones: The cones to be considered.
            reference_hyperplanes: The hyperplanes whose bisections we want.
            positions: The bisections of the given cones for each hyperplane.
        &#34;&#34;&#34;
        now = datetime.now()

        with open(self.intersection_file, &#39;w+&#39;) as file:
            file.write(f&#39;NAME: {self.name}\n&#39;)
            file.write(f&#39;TYPE: {self.type.upper()}\n&#39;)
            file.write(f&#39;GENERATED: {now.strftime(&#34;%d/%m/%Y %H:%M:%S&#34;)}\n&#39;)
            file.write(f&#39;REGION: {str(region)}\n&#39;)
            file.write(f&#39;HASH: {repr(region)}\n&#39;)
            file.write(f&#39;HYPERPLANES: {reference_hyperplanes}\n&#39;)
            file.write(f&#39;SOLUTIONS: {reference_cones}\n\n&#39;)

            file.write(f&#39;POSITION SECTION\n&#39;)
            for (index, bisection) in positions.items():
                file.write(f&#39;{index}: {repr(bisection)}\n&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tinypy.geometry.intersections.Intersections"><code class="flex name class">
<span>class <span class="ident">Intersections</span></span>
<span>(</span><span>polytope: <a title="tinypy.polytopes.base_polytope.Polytope" href="../polytopes/base_polytope.html#tinypy.polytopes.base_polytope.Polytope">Polytope</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the intersections of hyperplanes and solution cones.</p>
<p>The files are stored in order to speed up the process in case of any kind
of interruptions.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>type</code></strong></dt>
<dd>The instance type.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>The instance name.</dd>
<dt><strong><code>intersection_file</code></strong></dt>
<dd>The path where the intersections should be stored.</dd>
<dt><strong><code>polytope</code></strong></dt>
<dd>The polytope.</dd>
<dt><strong><code>hyperplanes</code></strong></dt>
<dd>The polytope's set of hyperplanes.</dd>
<dt><strong><code>cones</code></strong></dt>
<dd>The polytope's solution cones.</dd>
<dt><strong><code>intersection_lp</code></strong></dt>
<dd>Instance of the intersection linear program model.</dd>
</dl>
<p>Initializes the intersections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>polytope</code></strong></dt>
<dd>The polytope.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Intersections:
    &#34;&#34;&#34;Computes the intersections of hyperplanes and solution cones.

    The files are stored in order to speed up the process in case of any kind
    of interruptions.


    Attributes:
        type: The instance type.
        name: The instance name.
        intersection_file: The path where the intersections should be stored.
        polytope: The polytope.
        hyperplanes: The polytope&#39;s set of hyperplanes.
        cones: The polytope&#39;s solution cones.
        intersection_lp: Instance of the intersection linear program model.
    &#34;&#34;&#34;

    type: str
    name: str
    intersection_file: str

    polytope: Polytope
    hyperplanes: Dict[int, &#39;Hyperplane&#39;]
    cones: Dict[int, &#39;Cone&#39;]
    intersection_lp: IntersectionProblem

    def __init__(self, polytope: Polytope):
        &#34;&#34;&#34;Initializes the intersections.

        Args:
            polytope: The polytope.
        &#34;&#34;&#34;
        self.type = polytope.instance.type
        self.name = polytope.instance.name

        self.polytope = polytope
        self.hyperplanes = polytope.H
        self.hyperplanes.update(polytope.extended_H)
        self.cones = polytope.voronoi.cones
        self.intersection_lp = IntersectionProblem(polytope.dimension, polytope.instance.name, polytope.voronoi.cones, polytope.H, True)

    def clear_files(self):
        &#34;&#34;&#34;Deletes the files used to stored previous results.
        &#34;&#34;&#34;
        delete_directory(get_full_path(&#39;files&#39;, &#39;intersections&#39;, self.type))

    def clear_lp_files(self):
        &#34;&#34;&#34;Deletes the files used by the linear program.
        &#34;&#34;&#34;
        self.intersection_lp.clear_files()

    def get_positions(self, region: &#39;Region&#39;, cones: List[int], hyperplanes: List[int]) -&gt; Dict[int, &#39;Bisection&#39;]:
        &#34;&#34;&#34;Returns the the positions of cones with respect to hyperplanes.

        Args:
            region: The region to be considered.
            cones: The cones to be considered.
            hyperplanes: The hyperplanes whose bisections we want.

        Returns:
            The bisections of the given cones for each hyperplane.
        &#34;&#34;&#34;
        self.intersection_file = get_full_path(&#39;files&#39;, &#39;intersections&#39;, self.type, self.name, f&#39;{repr(region)}.tptf&#39;)
        create_directory(get_full_path(&#39;files&#39;, &#39;intersections&#39;, self.type, self.name))

        if file_exists(self.intersection_file):
            positions = self.__read_intersection_file(len(hyperplanes))
        else:
            positions = self.__compute_positions(region, cones, hyperplanes)
            self.__write_intersection_file(region, cones, hyperplanes, positions)

        return positions

    def __compute_positions(self, region: &#39;Region&#39;, reference_cones: List[int], reference_hyperplanes: List[int]) -&gt; Dict[int, &#39;Bisection&#39;]:
        &#34;&#34;&#34;Returns the the positions of cones with respect to hyperplanes.

        Args:
            region: The region to be considered.
            reference_cones: The cones to be considered.
            reference_hyperplanes: The hyperplanes whose bisections we want.

        Returns:
            The bisections of the given cones for each hyperplane.
        &#34;&#34;&#34;
        intersections = self.__compute_intersections(region, reference_cones, reference_hyperplanes)
        positions = dict()

        for h in reference_hyperplanes:
            positions[h] = Bisection()
            cones = [c for (c, value) in intersections[h].items() if value is False]

            for c in cones:
                if self.hyperplanes[h].in_halfspace(self.cones[c].solution):
                    positions[h].add_right(c)
                else:
                    positions[h].add_left(c)

        return positions

    def __compute_intersections(self, region: &#39;Region&#39;, reference_cones: List[int], reference_hyperplanes: List[int]) -&gt; Dict[int, Dict[int, bool]]:
        &#34;&#34;&#34;Computes the intersections of each hyperplane with each cone.

        Args:
            region: The region to be considered.
            reference_cones: The cones to be considered.
            reference_hyperplanes: The hyperplanes whose bisections we want.

        Returns:
            The intersections of the hyperplanes with cones.
        &#34;&#34;&#34;
        intersections = dict()

        for h in reference_hyperplanes:
            intersections[h] = dict()

            for c in reference_cones:
                intersections[h][c] = self.intersection_lp.test_intersection(region, c, h)

        return intersections

    def __read_intersection_file(self, p_size: int) -&gt; Dict[int, &#39;Bisection&#39;]:
        &#34;&#34;&#34;Reads the intersection file.

        Args:
            p_size: The number of hyperplanes.

        Returns:
            The bisections of the given cones for each hyperplane.
        &#34;&#34;&#34;
        positions = dict()

        with open(self.intersection_file, &#39;r&#39;) as file:
            file.readline()     # name
            file.readline()     # type
            file.readline()     # generated
            file.readline()     # region
            file.readline()     # hash
            file.readline()     # hyperplanes
            file.readline()     # solutions
            file.readline()

            file.readline()     # POSITION SECTION
            for _ in range(p_size):
                line = file.readline().split(&#39;:&#39;)
                key = int(line[0].strip())
                bisection_tuple = make_tuple(line[1].strip())
                bisection = Bisection(bisection_tuple[0], bisection_tuple[1])
                positions[key] = bisection

        return positions

    def __write_intersection_file(self, region: &#39;Region&#39;, reference_cones: List[int],
                                  reference_hyperplanes: List[int], positions: Dict[int, &#39;Bisection&#39;]):
        &#34;&#34;&#34;Writes the intersection file.

        Args:
            region: The region to be considered.
            reference_cones: The cones to be considered.
            reference_hyperplanes: The hyperplanes whose bisections we want.
            positions: The bisections of the given cones for each hyperplane.
        &#34;&#34;&#34;
        now = datetime.now()

        with open(self.intersection_file, &#39;w+&#39;) as file:
            file.write(f&#39;NAME: {self.name}\n&#39;)
            file.write(f&#39;TYPE: {self.type.upper()}\n&#39;)
            file.write(f&#39;GENERATED: {now.strftime(&#34;%d/%m/%Y %H:%M:%S&#34;)}\n&#39;)
            file.write(f&#39;REGION: {str(region)}\n&#39;)
            file.write(f&#39;HASH: {repr(region)}\n&#39;)
            file.write(f&#39;HYPERPLANES: {reference_hyperplanes}\n&#39;)
            file.write(f&#39;SOLUTIONS: {reference_cones}\n\n&#39;)

            file.write(f&#39;POSITION SECTION\n&#39;)
            for (index, bisection) in positions.items():
                file.write(f&#39;{index}: {repr(bisection)}\n&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tinypy.geometry.intersections.Intersections.clear_files"><code class="name flex">
<span>def <span class="ident">clear_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the files used to stored previous results.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_files(self):
    &#34;&#34;&#34;Deletes the files used to stored previous results.
    &#34;&#34;&#34;
    delete_directory(get_full_path(&#39;files&#39;, &#39;intersections&#39;, self.type))</code></pre>
</details>
</dd>
<dt id="tinypy.geometry.intersections.Intersections.clear_lp_files"><code class="name flex">
<span>def <span class="ident">clear_lp_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the files used by the linear program.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_lp_files(self):
    &#34;&#34;&#34;Deletes the files used by the linear program.
    &#34;&#34;&#34;
    self.intersection_lp.clear_files()</code></pre>
</details>
</dd>
<dt id="tinypy.geometry.intersections.Intersections.get_positions"><code class="name flex">
<span>def <span class="ident">get_positions</span></span>(<span>self, region: Region, cones: List[int], hyperplanes: List[int]) ‑> Dict[int, <a title="tinypy.geometry.bisection.Bisection" href="bisection.html#tinypy.geometry.bisection.Bisection">Bisection</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the the positions of cones with respect to hyperplanes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>region</code></strong></dt>
<dd>The region to be considered.</dd>
<dt><strong><code>cones</code></strong></dt>
<dd>The cones to be considered.</dd>
<dt><strong><code>hyperplanes</code></strong></dt>
<dd>The hyperplanes whose bisections we want.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The bisections of the given cones for each hyperplane.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_positions(self, region: &#39;Region&#39;, cones: List[int], hyperplanes: List[int]) -&gt; Dict[int, &#39;Bisection&#39;]:
    &#34;&#34;&#34;Returns the the positions of cones with respect to hyperplanes.

    Args:
        region: The region to be considered.
        cones: The cones to be considered.
        hyperplanes: The hyperplanes whose bisections we want.

    Returns:
        The bisections of the given cones for each hyperplane.
    &#34;&#34;&#34;
    self.intersection_file = get_full_path(&#39;files&#39;, &#39;intersections&#39;, self.type, self.name, f&#39;{repr(region)}.tptf&#39;)
    create_directory(get_full_path(&#39;files&#39;, &#39;intersections&#39;, self.type, self.name))

    if file_exists(self.intersection_file):
        positions = self.__read_intersection_file(len(hyperplanes))
    else:
        positions = self.__compute_positions(region, cones, hyperplanes)
        self.__write_intersection_file(region, cones, hyperplanes, positions)

    return positions</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tinypy.geometry" href="index.html">tinypy.geometry</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tinypy.geometry.intersections.Intersections" href="#tinypy.geometry.intersections.Intersections">Intersections</a></code></h4>
<ul class="">
<li><code><a title="tinypy.geometry.intersections.Intersections.clear_files" href="#tinypy.geometry.intersections.Intersections.clear_files">clear_files</a></code></li>
<li><code><a title="tinypy.geometry.intersections.Intersections.clear_lp_files" href="#tinypy.geometry.intersections.Intersections.clear_lp_files">clear_lp_files</a></code></li>
<li><code><a title="tinypy.geometry.intersections.Intersections.get_positions" href="#tinypy.geometry.intersections.Intersections.get_positions">get_positions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>