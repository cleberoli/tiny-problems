<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>tinypy.polytopes.base_polytope API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tinypy.polytopes.base_polytope</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from abc import ABC
from datetime import datetime
from typing import Dict, Tuple

from tinypy.geometry.point import Point
from tinypy.geometry.hyperplane import Hyperplane
from tinypy.geometry.voronoi import VoronoiDiagram
from tinypy.graph.delaunay import DelaunayTriangulation
from tinypy.graph.skeleton import Skeleton
from tinypy.instances.base_instance import Instance
from tinypy.lp.adjacency import AdjacencyProblem
from tinypy.utils.file import create_directory, file_exists, get_full_path


class Polytope(ABC):
    &#34;&#34;&#34;Base class that build the polytopes for different instances.

    Attributes:
        full_name: The polytope full name.
        name: The instance name.
        dimension: The instance dimension.
        size: The instance size.
        n: The instance main parameter.
        skeleton_file: The path where the skeleton should be stored.
        polytope_file: The path where the polytope should be stored.
        instance: The instance.
        skeleton: The skeleton graph.
        extended_skeleton: The extended skeleton graph.
        H: The set of hyperplanes.
        extended_H: The extended set of hyperplanes.
        delaunay: The Delaunay triangulation.
        voronoi: The Voronoi diagram.
        vertices: The polytope vertices.
    &#34;&#34;&#34;

    full_name: str
    name: str
    dimension: int
    size: int
    n: int
    skeleton_file: str
    polytope_file: str

    instance: Instance
    skeleton: Skeleton
    extended_skeleton: Skeleton
    H: Dict[int, &#39;Hyperplane&#39;]
    extended_H: Dict[int, &#39;Hyperplane&#39;]
    delaunay: DelaunayTriangulation
    voronoi: VoronoiDiagram
    vertices: Dict[int, Point]

    def __init__(self, instance: Instance, full_name: str):
        &#34;&#34;&#34;Initializes the polytope with the given instance and name.

        Args:
            instance: The instance.
            full_name: The polytope full name.
        &#34;&#34;&#34;
        self.instance = instance
        self.full_name = full_name
        self.name = self.instance.type
        self.dimension = self.instance.dimension
        self.size = self.instance.size
        self.n = self.instance.n
        self.skeleton_file = get_full_path(&#39;files&#39;, &#39;skeletons&#39;, self.instance.type, f&#39;{self.instance.name}.tpsf&#39;)
        self.polytope_file = get_full_path(&#39;files&#39;, &#39;polytopes&#39;, self.instance.type, f&#39;{self.instance.name}.tppf&#39;)
        create_directory(get_full_path(&#39;files&#39;, &#39;skeletons&#39;, self.instance.type))
        create_directory(get_full_path(&#39;files&#39;, &#39;polytopes&#39;, self.instance.type))

        self.vertices = self.instance.get_solution_dict().copy()
        self.vertices = dict((key, Point([1] * self.dimension) - 2 * point) for (key, point) in self.vertices.items())

        self.build_skeleton()
        self.delaunay = DelaunayTriangulation(self.skeleton)
        self.voronoi = VoronoiDiagram(self.delaunay, self.H, self.instance.type, self.instance.name)
        self.voronoi.build(self.vertices)

        if not file_exists(self.polytope_file):
            self.__write_polytope_file()

    def build_skeleton(self):
        &#34;&#34;&#34;Build the polytope skeleton.

        If the skeleton has been previously computed it is loaded from the file.
        Otherwise it is generated and saved.
        &#34;&#34;&#34;
        if file_exists(self.skeleton_file):
            self.skeleton, self.H, self.extended_skeleton, self.extended_H = self.__read_skeleton_file()
        else:
            self.skeleton, self.H, self.extended_skeleton, self.extended_H = self.__generate_skeleton()
            self.__write_skeleton_file()

    def get_bisector(self, i: int, j: int) -&gt; int:
        &#34;&#34;&#34;Returns the bisector of two points.

        Args:
            i: First node.
            j: Second node.

        Returns:
            The index of the bisector hyperplane, chosen from the skeleton or
            the extended skeleton.
        &#34;&#34;&#34;
        if self.skeleton.has_edge(i, j):
            return self.skeleton.get_edge(i, j, &#39;h&#39;)
        else:
            return self.extended_skeleton.get_edge(i, j, &#39;h&#39;)

    def __generate_skeleton(self) -&gt; Tuple[&#39;Skeleton&#39;, Dict[int, &#39;Hyperplane&#39;], &#39;Skeleton&#39;, Dict[int, &#39;Hyperplane&#39;]]:
        &#34;&#34;&#34;Generates the skeleton along with the hyperplanes.

        Returns:
            The skeleton graph.
            The set of hyperplanes.
            The extended skeleton graph.
            The extended set of hyperplanes.
        &#34;&#34;&#34;
        skeleton = Skeleton()
        extended_skeleton = Skeleton()
        adjacency_lp = AdjacencyProblem(self.dimension, self.instance.name, self.vertices)
        hyperplanes = set()
        extended_hyperplanes = set()
        vertices = self.instance.get_solution_dict()

        for i in range(1, self.size + 1):
            for j in range(i + 1, self.size + 1):
                h = Hyperplane(vertices[j] - vertices[i], d=0)

                if adjacency_lp.test_edge_primal(i, j):
                    hyperplanes.add(h)
                    skeleton.add_edge(i, j, h=hash(h))
                else:
                    extended_hyperplanes.add(h)
                    extended_skeleton.add_edge(i, j, h=hash(h))

        adjacency_lp.clear_files()

        hyperplanes = list(hyperplanes)
        hyperplanes.sort()
        hyperplanes = dict((key + 1, hyperplanes[key]) for key in range(len(hyperplanes)))

        extended_hyperplanes = list(extended_hyperplanes)
        extended_hyperplanes.sort()
        extended_hyperplanes = dict((key + len(hyperplanes) + 1, extended_hyperplanes[key]) for key in range(len(extended_hyperplanes)))

        map_dict = {hash(hyperplanes[i]): i for i in hyperplanes.keys()}
        extended_map_dict = {hash(extended_hyperplanes[i]): i for i in extended_hyperplanes.keys()}

        for edge in skeleton.edges:
            skeleton.add_edge(edge[0], edge[1], h=map_dict[skeleton.get_edge(edge[0], edge[1], &#39;h&#39;)])

        for edge in extended_skeleton.edges:
            extended_skeleton.add_edge(edge[0], edge[1], h=extended_map_dict[extended_skeleton.get_edge(edge[0], edge[1], &#39;h&#39;)])

        return skeleton, hyperplanes, extended_skeleton, extended_hyperplanes

    def __read_skeleton_file(self) -&gt; Tuple[&#39;Skeleton&#39;, Dict[int, &#39;Hyperplane&#39;], &#39;Skeleton&#39;, Dict[int, &#39;Hyperplane&#39;]]:
        &#34;&#34;&#34;Loads the skeleton from the file.

        Returns:
            The skeleton graph.
            The set of hyperplanes.
            The extended skeleton graph.
            The extended set of hyperplanes.
        &#34;&#34;&#34;
        skeleton = Skeleton()
        hyperplanes = dict()
        extended_skeleton = Skeleton()
        extended_hyperplanes = dict()

        with open(self.skeleton_file, &#39;r&#39;) as file:
            file.readline()     # name
            file.readline()     # type
            file.readline()     # generated
            file.readline()     # dimension
            file.readline()     # size
            h_size = int(file.readline().split()[1])
            e_size = int(file.readline().split()[1])
            e_h_size = int(file.readline().split()[2])
            e_e_size = int(file.readline().split()[2])
            file.readline()

            file.readline()     # HYPERPLANES SECTION
            for _ in range(h_size):
                line = file.readline().split(&#39;:&#39;)
                key = int(line[0].strip())
                hyperplane = list(map(int, line[1].split()))
                hyperplane = Hyperplane(Point(hyperplane[:-1]), d=hyperplane[-1])
                hyperplanes[key] = hyperplane
            file.readline()

            file.readline()     # SKELETON SECTION
            for _ in range(e_size):
                edge = list(map(int, file.readline().split()))
                skeleton.add_edge(edge[0], edge[1], h=edge[2])
            file.readline()

            file.readline()  # EXTENDED HYPERPLANES SECTION
            for _ in range(e_h_size):
                line = file.readline().split(&#39;:&#39;)
                key = int(line[0].strip())
                hyperplane = list(map(int, line[1].split()))
                hyperplane = Hyperplane(Point(hyperplane[:-1]), d=hyperplane[-1])
                extended_hyperplanes[key] = hyperplane
            file.readline()

            file.readline()  # SKELETON SECTION
            for _ in range(e_e_size):
                edge = list(map(int, file.readline().split()))
                extended_skeleton.add_edge(edge[0], edge[1], h=edge[2])

        return skeleton, hyperplanes, extended_skeleton, extended_hyperplanes

    def __write_skeleton_file(self):
        &#34;&#34;&#34;Writes the skeleton to a file.
        &#34;&#34;&#34;
        now = datetime.now()

        with open(self.skeleton_file, &#39;w+&#39;) as file:
            file.write(f&#39;NAME: {self.instance.name}\n&#39;)
            file.write(f&#39;TYPE: {self.instance.type.upper()}\n&#39;)
            file.write(f&#39;GENERATED: {now.strftime(&#34;%d/%m/%Y %H:%M:%S&#34;)}\n&#39;)
            file.write(f&#39;DIMENSION: {self.dimension}\n&#39;)
            file.write(f&#39;SOLUTIONS: {self.size}\n&#39;)
            file.write(f&#39;HYPERPLANES: {len(self.H)}\n&#39;)
            file.write(f&#39;EDGES: {len(self.skeleton.edges)}\n&#39;)
            file.write(f&#39;EXTENDED HYPERPLANES: {len(self.extended_H)}\n&#39;)
            file.write(f&#39;EXTENDED EDGES: {len(self.extended_skeleton.edges)}\n\n&#39;)

            file.write(f&#39;HYPERPLANES SECTION\n&#39;)
            for (index, hyperplane) in self.H.items():
                file.write(f&#39;{index}: {&#34; &#34;.join(map(str, hyperplane.normal))} {hyperplane.d}\n&#39;)
            file.write(&#39;\n&#39;)

            file.write(f&#39;SKELETON SECTION\n&#39;)
            for edge in self.skeleton.edges:
                file.write(f&#39;{edge[0]} {edge[1]} {self.skeleton.get_edge(edge[0], edge[1], &#34;h&#34;)}\n&#39;)
            file.write(&#39;\n&#39;)

            file.write(f&#39;EXTENDED HYPERPLANES SECTION\n&#39;)
            for (index, hyperplane) in self.extended_H.items():
                file.write(f&#39;{index}: {&#34; &#34;.join(map(str, hyperplane.normal))} {hyperplane.d}\n&#39;)
            file.write(&#39;\n&#39;)

            file.write(f&#39;EXTENDED SKELETON SECTION\n&#39;)
            for edge in self.extended_skeleton.edges:
                file.write(f&#39;{edge[0]} {edge[1]} {self.extended_skeleton.get_edge(edge[0], edge[1], &#34;h&#34;)}\n&#39;)

    def __write_polytope_file(self):
        &#34;&#34;&#34;Writes the polytope to a file.
        &#34;&#34;&#34;
        with open(self.polytope_file, &#39;w+&#39;) as file:
            file.write(repr(self))

    def __repr__(self):  # pragma: no cover
        degrees = [self.skeleton.graph.degree(i) for i in self.skeleton.graph.nodes]

        return f&#39;NAME: {self.instance.name}\n&#39; \
               f&#39;TYPE: {self.instance.type.upper()}\n&#39; \
               f&#39;DIMENSION: {self.dimension}\n&#39; \
               f&#39;SOLUTIONS: {self.size}\n&#39; \
               f&#39;HYPERPLANES: {len(self.H)}\n&#39; \
               f&#39;EDGES: {len(self.skeleton.edges)}\n&#39; \
               f&#39;AVERAGE DEGREE: {sum(degrees) / max(len(degrees), 1)}\n&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tinypy.polytopes.base_polytope.Polytope"><code class="flex name class">
<span>class <span class="ident">Polytope</span></span>
<span>(</span><span>instance: <a title="tinypy.instances.base_instance.Instance" href="../instances/base_instance.html#tinypy.instances.base_instance.Instance">Instance</a>, full_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class that build the polytopes for different instances.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>full_name</code></strong></dt>
<dd>The polytope full name.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>The instance name.</dd>
<dt><strong><code>dimension</code></strong></dt>
<dd>The instance dimension.</dd>
<dt><strong><code>size</code></strong></dt>
<dd>The instance size.</dd>
<dt><strong><code>n</code></strong></dt>
<dd>The instance main parameter.</dd>
<dt><strong><code>skeleton_file</code></strong></dt>
<dd>The path where the skeleton should be stored.</dd>
<dt><strong><code>polytope_file</code></strong></dt>
<dd>The path where the polytope should be stored.</dd>
<dt><strong><code>instance</code></strong></dt>
<dd>The instance.</dd>
<dt><strong><code>skeleton</code></strong></dt>
<dd>The skeleton graph.</dd>
<dt><strong><code>extended_skeleton</code></strong></dt>
<dd>The extended skeleton graph.</dd>
<dt><strong><code>H</code></strong></dt>
<dd>The set of hyperplanes.</dd>
<dt><strong><code>extended_H</code></strong></dt>
<dd>The extended set of hyperplanes.</dd>
<dt><strong><code>delaunay</code></strong></dt>
<dd>The Delaunay triangulation.</dd>
<dt><strong><code>voronoi</code></strong></dt>
<dd>The Voronoi diagram.</dd>
<dt><strong><code>vertices</code></strong></dt>
<dd>The polytope vertices.</dd>
</dl>
<p>Initializes the polytope with the given instance and name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instance</code></strong></dt>
<dd>The instance.</dd>
<dt><strong><code>full_name</code></strong></dt>
<dd>The polytope full name.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Polytope(ABC):
    &#34;&#34;&#34;Base class that build the polytopes for different instances.

    Attributes:
        full_name: The polytope full name.
        name: The instance name.
        dimension: The instance dimension.
        size: The instance size.
        n: The instance main parameter.
        skeleton_file: The path where the skeleton should be stored.
        polytope_file: The path where the polytope should be stored.
        instance: The instance.
        skeleton: The skeleton graph.
        extended_skeleton: The extended skeleton graph.
        H: The set of hyperplanes.
        extended_H: The extended set of hyperplanes.
        delaunay: The Delaunay triangulation.
        voronoi: The Voronoi diagram.
        vertices: The polytope vertices.
    &#34;&#34;&#34;

    full_name: str
    name: str
    dimension: int
    size: int
    n: int
    skeleton_file: str
    polytope_file: str

    instance: Instance
    skeleton: Skeleton
    extended_skeleton: Skeleton
    H: Dict[int, &#39;Hyperplane&#39;]
    extended_H: Dict[int, &#39;Hyperplane&#39;]
    delaunay: DelaunayTriangulation
    voronoi: VoronoiDiagram
    vertices: Dict[int, Point]

    def __init__(self, instance: Instance, full_name: str):
        &#34;&#34;&#34;Initializes the polytope with the given instance and name.

        Args:
            instance: The instance.
            full_name: The polytope full name.
        &#34;&#34;&#34;
        self.instance = instance
        self.full_name = full_name
        self.name = self.instance.type
        self.dimension = self.instance.dimension
        self.size = self.instance.size
        self.n = self.instance.n
        self.skeleton_file = get_full_path(&#39;files&#39;, &#39;skeletons&#39;, self.instance.type, f&#39;{self.instance.name}.tpsf&#39;)
        self.polytope_file = get_full_path(&#39;files&#39;, &#39;polytopes&#39;, self.instance.type, f&#39;{self.instance.name}.tppf&#39;)
        create_directory(get_full_path(&#39;files&#39;, &#39;skeletons&#39;, self.instance.type))
        create_directory(get_full_path(&#39;files&#39;, &#39;polytopes&#39;, self.instance.type))

        self.vertices = self.instance.get_solution_dict().copy()
        self.vertices = dict((key, Point([1] * self.dimension) - 2 * point) for (key, point) in self.vertices.items())

        self.build_skeleton()
        self.delaunay = DelaunayTriangulation(self.skeleton)
        self.voronoi = VoronoiDiagram(self.delaunay, self.H, self.instance.type, self.instance.name)
        self.voronoi.build(self.vertices)

        if not file_exists(self.polytope_file):
            self.__write_polytope_file()

    def build_skeleton(self):
        &#34;&#34;&#34;Build the polytope skeleton.

        If the skeleton has been previously computed it is loaded from the file.
        Otherwise it is generated and saved.
        &#34;&#34;&#34;
        if file_exists(self.skeleton_file):
            self.skeleton, self.H, self.extended_skeleton, self.extended_H = self.__read_skeleton_file()
        else:
            self.skeleton, self.H, self.extended_skeleton, self.extended_H = self.__generate_skeleton()
            self.__write_skeleton_file()

    def get_bisector(self, i: int, j: int) -&gt; int:
        &#34;&#34;&#34;Returns the bisector of two points.

        Args:
            i: First node.
            j: Second node.

        Returns:
            The index of the bisector hyperplane, chosen from the skeleton or
            the extended skeleton.
        &#34;&#34;&#34;
        if self.skeleton.has_edge(i, j):
            return self.skeleton.get_edge(i, j, &#39;h&#39;)
        else:
            return self.extended_skeleton.get_edge(i, j, &#39;h&#39;)

    def __generate_skeleton(self) -&gt; Tuple[&#39;Skeleton&#39;, Dict[int, &#39;Hyperplane&#39;], &#39;Skeleton&#39;, Dict[int, &#39;Hyperplane&#39;]]:
        &#34;&#34;&#34;Generates the skeleton along with the hyperplanes.

        Returns:
            The skeleton graph.
            The set of hyperplanes.
            The extended skeleton graph.
            The extended set of hyperplanes.
        &#34;&#34;&#34;
        skeleton = Skeleton()
        extended_skeleton = Skeleton()
        adjacency_lp = AdjacencyProblem(self.dimension, self.instance.name, self.vertices)
        hyperplanes = set()
        extended_hyperplanes = set()
        vertices = self.instance.get_solution_dict()

        for i in range(1, self.size + 1):
            for j in range(i + 1, self.size + 1):
                h = Hyperplane(vertices[j] - vertices[i], d=0)

                if adjacency_lp.test_edge_primal(i, j):
                    hyperplanes.add(h)
                    skeleton.add_edge(i, j, h=hash(h))
                else:
                    extended_hyperplanes.add(h)
                    extended_skeleton.add_edge(i, j, h=hash(h))

        adjacency_lp.clear_files()

        hyperplanes = list(hyperplanes)
        hyperplanes.sort()
        hyperplanes = dict((key + 1, hyperplanes[key]) for key in range(len(hyperplanes)))

        extended_hyperplanes = list(extended_hyperplanes)
        extended_hyperplanes.sort()
        extended_hyperplanes = dict((key + len(hyperplanes) + 1, extended_hyperplanes[key]) for key in range(len(extended_hyperplanes)))

        map_dict = {hash(hyperplanes[i]): i for i in hyperplanes.keys()}
        extended_map_dict = {hash(extended_hyperplanes[i]): i for i in extended_hyperplanes.keys()}

        for edge in skeleton.edges:
            skeleton.add_edge(edge[0], edge[1], h=map_dict[skeleton.get_edge(edge[0], edge[1], &#39;h&#39;)])

        for edge in extended_skeleton.edges:
            extended_skeleton.add_edge(edge[0], edge[1], h=extended_map_dict[extended_skeleton.get_edge(edge[0], edge[1], &#39;h&#39;)])

        return skeleton, hyperplanes, extended_skeleton, extended_hyperplanes

    def __read_skeleton_file(self) -&gt; Tuple[&#39;Skeleton&#39;, Dict[int, &#39;Hyperplane&#39;], &#39;Skeleton&#39;, Dict[int, &#39;Hyperplane&#39;]]:
        &#34;&#34;&#34;Loads the skeleton from the file.

        Returns:
            The skeleton graph.
            The set of hyperplanes.
            The extended skeleton graph.
            The extended set of hyperplanes.
        &#34;&#34;&#34;
        skeleton = Skeleton()
        hyperplanes = dict()
        extended_skeleton = Skeleton()
        extended_hyperplanes = dict()

        with open(self.skeleton_file, &#39;r&#39;) as file:
            file.readline()     # name
            file.readline()     # type
            file.readline()     # generated
            file.readline()     # dimension
            file.readline()     # size
            h_size = int(file.readline().split()[1])
            e_size = int(file.readline().split()[1])
            e_h_size = int(file.readline().split()[2])
            e_e_size = int(file.readline().split()[2])
            file.readline()

            file.readline()     # HYPERPLANES SECTION
            for _ in range(h_size):
                line = file.readline().split(&#39;:&#39;)
                key = int(line[0].strip())
                hyperplane = list(map(int, line[1].split()))
                hyperplane = Hyperplane(Point(hyperplane[:-1]), d=hyperplane[-1])
                hyperplanes[key] = hyperplane
            file.readline()

            file.readline()     # SKELETON SECTION
            for _ in range(e_size):
                edge = list(map(int, file.readline().split()))
                skeleton.add_edge(edge[0], edge[1], h=edge[2])
            file.readline()

            file.readline()  # EXTENDED HYPERPLANES SECTION
            for _ in range(e_h_size):
                line = file.readline().split(&#39;:&#39;)
                key = int(line[0].strip())
                hyperplane = list(map(int, line[1].split()))
                hyperplane = Hyperplane(Point(hyperplane[:-1]), d=hyperplane[-1])
                extended_hyperplanes[key] = hyperplane
            file.readline()

            file.readline()  # SKELETON SECTION
            for _ in range(e_e_size):
                edge = list(map(int, file.readline().split()))
                extended_skeleton.add_edge(edge[0], edge[1], h=edge[2])

        return skeleton, hyperplanes, extended_skeleton, extended_hyperplanes

    def __write_skeleton_file(self):
        &#34;&#34;&#34;Writes the skeleton to a file.
        &#34;&#34;&#34;
        now = datetime.now()

        with open(self.skeleton_file, &#39;w+&#39;) as file:
            file.write(f&#39;NAME: {self.instance.name}\n&#39;)
            file.write(f&#39;TYPE: {self.instance.type.upper()}\n&#39;)
            file.write(f&#39;GENERATED: {now.strftime(&#34;%d/%m/%Y %H:%M:%S&#34;)}\n&#39;)
            file.write(f&#39;DIMENSION: {self.dimension}\n&#39;)
            file.write(f&#39;SOLUTIONS: {self.size}\n&#39;)
            file.write(f&#39;HYPERPLANES: {len(self.H)}\n&#39;)
            file.write(f&#39;EDGES: {len(self.skeleton.edges)}\n&#39;)
            file.write(f&#39;EXTENDED HYPERPLANES: {len(self.extended_H)}\n&#39;)
            file.write(f&#39;EXTENDED EDGES: {len(self.extended_skeleton.edges)}\n\n&#39;)

            file.write(f&#39;HYPERPLANES SECTION\n&#39;)
            for (index, hyperplane) in self.H.items():
                file.write(f&#39;{index}: {&#34; &#34;.join(map(str, hyperplane.normal))} {hyperplane.d}\n&#39;)
            file.write(&#39;\n&#39;)

            file.write(f&#39;SKELETON SECTION\n&#39;)
            for edge in self.skeleton.edges:
                file.write(f&#39;{edge[0]} {edge[1]} {self.skeleton.get_edge(edge[0], edge[1], &#34;h&#34;)}\n&#39;)
            file.write(&#39;\n&#39;)

            file.write(f&#39;EXTENDED HYPERPLANES SECTION\n&#39;)
            for (index, hyperplane) in self.extended_H.items():
                file.write(f&#39;{index}: {&#34; &#34;.join(map(str, hyperplane.normal))} {hyperplane.d}\n&#39;)
            file.write(&#39;\n&#39;)

            file.write(f&#39;EXTENDED SKELETON SECTION\n&#39;)
            for edge in self.extended_skeleton.edges:
                file.write(f&#39;{edge[0]} {edge[1]} {self.extended_skeleton.get_edge(edge[0], edge[1], &#34;h&#34;)}\n&#39;)

    def __write_polytope_file(self):
        &#34;&#34;&#34;Writes the polytope to a file.
        &#34;&#34;&#34;
        with open(self.polytope_file, &#39;w+&#39;) as file:
            file.write(repr(self))

    def __repr__(self):  # pragma: no cover
        degrees = [self.skeleton.graph.degree(i) for i in self.skeleton.graph.nodes]

        return f&#39;NAME: {self.instance.name}\n&#39; \
               f&#39;TYPE: {self.instance.type.upper()}\n&#39; \
               f&#39;DIMENSION: {self.dimension}\n&#39; \
               f&#39;SOLUTIONS: {self.size}\n&#39; \
               f&#39;HYPERPLANES: {len(self.H)}\n&#39; \
               f&#39;EDGES: {len(self.skeleton.edges)}\n&#39; \
               f&#39;AVERAGE DEGREE: {sum(degrees) / max(len(degrees), 1)}\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tinypy.polytopes.cut_polytope.CutPolytope" href="cut_polytope.html#tinypy.polytopes.cut_polytope.CutPolytope">CutPolytope</a></li>
<li><a title="tinypy.polytopes.hypercube_polytope.HypercubePolytope" href="hypercube_polytope.html#tinypy.polytopes.hypercube_polytope.HypercubePolytope">HypercubePolytope</a></li>
<li><a title="tinypy.polytopes.hyperpyramid_polytope.HyperpyramidPolytope" href="hyperpyramid_polytope.html#tinypy.polytopes.hyperpyramid_polytope.HyperpyramidPolytope">HyperpyramidPolytope</a></li>
<li><a title="tinypy.polytopes.random_polytope.RandomPolytope" href="random_polytope.html#tinypy.polytopes.random_polytope.RandomPolytope">RandomPolytope</a></li>
<li><a title="tinypy.polytopes.tsp_polytope.TSPPolytope" href="tsp_polytope.html#tinypy.polytopes.tsp_polytope.TSPPolytope">TSPPolytope</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tinypy.polytopes.base_polytope.Polytope.build_skeleton"><code class="name flex">
<span>def <span class="ident">build_skeleton</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Build the polytope skeleton.</p>
<p>If the skeleton has been previously computed it is loaded from the file.
Otherwise it is generated and saved.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_skeleton(self):
    &#34;&#34;&#34;Build the polytope skeleton.

    If the skeleton has been previously computed it is loaded from the file.
    Otherwise it is generated and saved.
    &#34;&#34;&#34;
    if file_exists(self.skeleton_file):
        self.skeleton, self.H, self.extended_skeleton, self.extended_H = self.__read_skeleton_file()
    else:
        self.skeleton, self.H, self.extended_skeleton, self.extended_H = self.__generate_skeleton()
        self.__write_skeleton_file()</code></pre>
</details>
</dd>
<dt id="tinypy.polytopes.base_polytope.Polytope.get_bisector"><code class="name flex">
<span>def <span class="ident">get_bisector</span></span>(<span>self, i: int, j: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the bisector of two points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>i</code></strong></dt>
<dd>First node.</dd>
<dt><strong><code>j</code></strong></dt>
<dd>Second node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The index of the bisector hyperplane, chosen from the skeleton or
the extended skeleton.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bisector(self, i: int, j: int) -&gt; int:
    &#34;&#34;&#34;Returns the bisector of two points.

    Args:
        i: First node.
        j: Second node.

    Returns:
        The index of the bisector hyperplane, chosen from the skeleton or
        the extended skeleton.
    &#34;&#34;&#34;
    if self.skeleton.has_edge(i, j):
        return self.skeleton.get_edge(i, j, &#39;h&#39;)
    else:
        return self.extended_skeleton.get_edge(i, j, &#39;h&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tinypy.polytopes" href="index.html">tinypy.polytopes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tinypy.polytopes.base_polytope.Polytope" href="#tinypy.polytopes.base_polytope.Polytope">Polytope</a></code></h4>
<ul class="">
<li><code><a title="tinypy.polytopes.base_polytope.Polytope.build_skeleton" href="#tinypy.polytopes.base_polytope.Polytope.build_skeleton">build_skeleton</a></code></li>
<li><code><a title="tinypy.polytopes.base_polytope.Polytope.get_bisector" href="#tinypy.polytopes.base_polytope.Polytope.get_bisector">get_bisector</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>